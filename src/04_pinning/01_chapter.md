# Pinning(固定)

To poll futures, they must be pinned using a special type called
`Pin<T>`. If you read the explanation of [the `Future` trait] in the
previous section ["Executing `Future`s and Tasks"], you'll recognize
`Pin` from the `self: Pin<&mut Self>` in the `Future::poll` method's definition.
But what does it mean, and why do we need it?

<p class="cn">
要轮询future，他们必须使用特定的称为`Pin<T>`的类型来固定。
如果您阅读上一节[执行`Future`s和任务]中对[`Future`特征]的解释，
您将从`Future::poll`方法定义中的`self: Pin<&mut Self>`中识别`Pin`。
但这意味着什么？我们为什么需要它？
</p>

## Why Pinning(为何要固定)

`Pin` works in tandem with the `Unpin` marker. Pinning makes it possible
to guarantee that an object implementing `!Unpin` won't ever be moved. To understand
why this is necessary, we need to remember how `async`/`.await` works. Consider
the following code:

<p class="cn">
`Pin`与`Unpin`标记配合使用。固定可以保证对象实现`!Unpin`永远不会被移动。
为了理解为什么这是必要的，我们需要记住`async`/`.await`是如何工作的。考虑以下代码：
</p>

```rust,edition2018,ignore
let fut_one = /* ... */;
let fut_two = /* ... */;
async move {
    fut_one.await;
    fut_two.await;
}
```

Under the hood, this creates an anonymous type that implements `Future`,
providing a `poll` method that looks something like this:

<p class="cn">
在后台，这将创建一个实现`Future`的匿名类型，提供一个类似以下内容的`poll`方法：
</p>

```rust,ignore
// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// List of states our `async` block can be in
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = State::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                State::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = State::Done,
                    Poll::Pending => return Poll::Pending,
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}
```


When `poll` is first called, it will poll `fut_one`. If `fut_one` can't
complete, `AsyncFuture::poll` will return. Future calls to `poll` will pick
up where the previous one left off. This process continues until the future
is able to successfully complete.

<p class="cn">
首次调用`poll`时，它将轮询`fut_one`。如果`fut_one`无法完成，将返回`AsyncFuture::poll`。
以后对`poll`的调用将继续前一个调用的中断。这一过程一直持续到future能够成功完成为止。
</p>

However, what happens if we have an `async` block that uses references?
For example:

<p class="cn">
然而，如果我们有一个使用引用的`async`块，会发生什么呢？
例如：
</p>

```rust,edition2018,ignore
async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&mut x);
    read_into_buf_fut.await;
    println!("{:?}", x);
}
```

What struct does this compile down to?

<p class="cn">
这个编译后到底是什么结构？
</p>

```rust,ignore
struct ReadIntoBuf<'a> {
    buf: &'a mut [u8], // points to `x` below
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf<'what_lifetime?>,
}
```

Here, the `ReadIntoBuf` future holds a reference into the other field of our
structure, `x`. However, if `AsyncFuture` is moved, the location of `x` will
move as well, invalidating the pointer stored in `read_into_buf_fut.buf`.

<p class="cn">
这里，`ReadIntoBuf` future引用了我们结构的另一个字段`x`。
但是，如果移动了`AsyncFuture`，则`x`的位置也将移动，从而使存储在`read_into_buf_fut.buf`中的指针无效。
</p>

Pinning futures to a particular spot in memory prevents this problem, making
it safe to create references to values inside an `async` block.

<p class="cn">
将future固定到内存中的特定位置可以防止此问题，使在`async`块中创建对值的引用是安全的。
</p>

## Pinning in Detail(固定的细节)

Let's try to understand pinning by using an slightly simpler example. The problem we encounter
above is a problem that ultimately boils down to how we handle references in self-referential
types in Rust.

<p class="cn">
让我们用一个稍微简单的例子来理解固定。我们在上面遇到的问题最终归结为我们如何在Rust中处理自引用类型中的引用。
</p>

For now our example will look like this:

<p class="cn">
现在，我们的示例如下所示：
</p>

```rust, ignore
#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.a;
        self.b = self_ref;
    }

    fn a(&self) -> &str {
        &self.a
    }

    fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

`Test` provides methods to get a reference to the value of the fields `a` and `b`. Since `b` is a
reference to `a` we store it as a pointer since the borrowing rules of Rust doesn't allow us to
define this lifetime. We now have what we call a self-referential struct.

<p class="cn">
`Test`提供了获取对字段'a'和'b'的值的引用的方法。由于'b'是对'a'的引用，我们将其存储为指针，因为Rust的借用规则不允许我们定义此生存期。
我们现在有了一个自我参照结构。
</p>

Our example works fine if we don't move any of our data around as you can observe by running
this example:

<p class="cn">
如果我们不移动任何数据，那么我们的示例可以很好地运行，您可以通过运行
此示例：
</p>

```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    println!("a: {}, b: {}", test2.a(), test2.b());

}
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
# }
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#         }
#     }
#
#     // We need an `init` method to actually set our self-reference
#     fn init(&mut self) {
#         let self_ref: *const String = &self.a;
#         self.b = self_ref;
#     }
#
#     fn a(&self) -> &str {
#         &self.a
#     }
#
#     fn b(&self) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```
We get what we'd expect:

<p class="cn">
我们得到了我们期望的结果
</p>

```rust, ignore
a: test1, b: test1
a: test2, b: test2
```

Let's see what happens if we swap `test1` with `test2` and thereby move the data:

<p class="cn">
让我们看看如果我们将`test1`与`test2`交换，从而移动数据会发生什么：
</p>

```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    println!("a: {}, b: {}", test2.a(), test2.b());

}
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
# }
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#         }
#     }
#
#     fn init(&mut self) {
#         let self_ref: *const String = &self.a;
#         self.b = self_ref;
#     }
#
#     fn a(&self) -> &str {
#         &self.a
#     }
#
#     fn b(&self) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```

Naively, we could think that what we should get a debug print of `test1` two times like this:

<p class="cn">
天真地，我们可以这样想，我们应该得到两次`test1`的调试打印：
</p>

```rust, ignore
a: test1, b: test1
a: test1, b: test1
```

But instead we get:

<p class="cn">
然而我们得到了下面的结果：
</p>

```rust, ignore
a: test1, b: test1
a: test1, b: test2
```

The pointer to `test2.b` still points to the old location which is inside `test1`
now. The struct is not self-referential anymore, it holds a pointer to a field
in a different object. That means we can't rely on the lifetime of `test2.b` to
be tied to the lifetime of `test2` anymore.

<p class="cn">
指向`test2.b`的指针现在仍然指向'test1'内的旧位置。结构不再是自引用的，它持有指向不同对象中字段的指针。
这意味着我们不能再依赖`test2.b`与'test2'的生存期相绑定。
</p>

If you're still not convinced, this should at least convince you:

<p class="cn">
如果你仍然不相信，下面的例子至少应该让你相信：
</p>

```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    test1.a = "I've totally changed now!".to_string();
    println!("a: {}, b: {}", test2.a(), test2.b());

}
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
# }
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#         }
#     }
#
#     fn init(&mut self) {
#         let self_ref: *const String = &self.a;
#         self.b = self_ref;
#     }
#
#     fn a(&self) -> &str {
#         &self.a
#     }
#
#     fn b(&self) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```

The diagram below can help visualize what's going on:

<p class="cn">
下图有助于直观显示发生的情况：
</p>

**Fig 1: Before and after swap**
![swap_problem](../assets/swap_problem.jpg)

It's easy to get this to show undefined behavior and fail in other spectacular ways as well.

<p class="cn">
很容易让它表现出未定义的行为，并以其他令人吃惊的方式失败。
</p>

## Pinning in Practice(固定的实践)

Let's see how pinning and the `Pin` type can help us solve this problem.

<p class="cn">
让我们看看pinning和`Pin`类型如何帮助我们解决这个问题。
</p>

The `Pin` type wraps pointer types, guaranteeing that the values behind the
pointer won't be moved. For example, `Pin<&mut T>`, `Pin<&T>`,
`Pin<Box<T>>` all guarantee that `T` won't be moved even if `T: !Unpin`.

<p class="cn">
`Pin`类型包装指针类型，确保指针后面的值不会移动。
例如，`Pin<&mut T>`, `Pin<&T>`, `Pin<Box<T>>`都保证即使`T: !Unpin`，也不会移动'T'。
</p>

Most types don't have a problem being moved. These types implement a trait
called `Unpin`. Pointers to `Unpin` types can be freely placed into or taken
out of `Pin`. For example, `u8` is `Unpin`, so `Pin<&mut u8>` behaves just like
a normal `&mut u8`.

<p class="cn">
大多数类型在移动时没有问题。这些类型实现了一个称为`Unpin`的特性。
指向`Unpin`类型的指针可以自由放入或取出`Pin`。
例如，`u8`是`Unpin`，因此`Pin<&mut u8>`的行为与普通的`mut u8`一样。
</p>

However, types that can't be moved after they're pinned have a marker called
`!Unpin`. Futures created by async/await is an example of this.

<p class="cn">
但是，固定后无法移动的类型有一个名为`!Unpin`的标记。async/await创建的future就是一个例子。
</p>

### Pinning to the Stack(固定到栈)

Back to our example. We can solve our problem by using `Pin`. Let's take a look at what
our example would look like if we required a pinned pointer instead:

<p class="cn">
回到我们的例子。我们可以用`Pin`来解决我们的问题。让我们看看如果我们需要一个固定指针，我们的示例会是什么样子：
</p>

```rust, ignore
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}


impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type `!Unpin`
        }
    }

    fn init(self: Pin<&mut Self>) {
        let self_ptr: *const String = &self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

Pinning an object to the stack will always be `unsafe` if our type implements
`!Unpin`. You can use a crate like [`pin_utils`][pin_utils] to avoid writing
our own `unsafe` code when pinning to the stack.

<p class="cn">
如果我们的类型实现了`!Unpin`，那么将对象固定到堆栈总是`unsafe`的。
您可以使用类似[`pin_utils`][pin_utils]的板条箱，以避免在固定到堆栈时编写我们自己的`不安全`代码。
</p>

Below, we pin the objects `test1` and `test2` to the stack:

<p class="cn">
下面，我们将对象`test1`和`test2`固定到堆栈中：
</p>

```rust
pub fn main() {
    // test1 is safe to move before we initialize it
    let mut test1 = Test::new("test1");
    // Notice how we shadow `test1` to prevent it from being accessed again
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
# use std::pin::Pin;
# use std::marker::PhantomPinned;
#
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
#     _marker: PhantomPinned,
# }
#
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#             // This makes our type `!Unpin`
#             _marker: PhantomPinned,
#         }
#     }
#
#     fn init(self: Pin<&mut Self>) {
#         let self_ptr: *const String = &self.a;
#         let this = unsafe { self.get_unchecked_mut() };
#         this.b = self_ptr;
#     }
#
#     fn a(self: Pin<&Self>) -> &str {
#         &self.get_ref().a
#     }
#
#     fn b(self: Pin<&Self>) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```

Now, if we try to move our data now we get a compilation error:

<p class="cn">
现在，如果我们现在尝试移动数据，就会出现编译错误：
</p>

```rust, compile_fail
pub fn main() {
    let mut test1 = Test::new("test1");
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
# use std::pin::Pin;
# use std::marker::PhantomPinned;
#
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
#     _marker: PhantomPinned,
# }
#
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#             _marker: PhantomPinned, // This makes our type `!Unpin`
#         }
#     }
#
#     fn init(self: Pin<&mut Self>) {
#         let self_ptr: *const String = &self.a;
#         let this = unsafe { self.get_unchecked_mut() };
#         this.b = self_ptr;
#     }
#
#     fn a(self: Pin<&Self>) -> &str {
#         &self.get_ref().a
#     }
#
#     fn b(self: Pin<&Self>) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```

The type system prevents us from moving the data.

<p class="cn">
类型系统阻止我们移动数据。
</p>

> It's important to note that stack pinning will always rely on guarantees
> you give when writing `unsafe`. While we know that the _pointee_ of `&'a mut T`
> is pinned for the lifetime of `'a` we can't know if the data `&'a mut T`
> points to isn't moved after `'a` ends. If it does it will violate the Pin
> contract.
>
> <p class="cn">需要注意的是，堆栈固定始终依赖于您在编写`unsafe`时提供的保证。虽然我们知道`&'a mut T`的指针对象在`'a`的生存期内是固定的，但我们不知道`&'a mut T`指向的数据在`'a`结束后是否没有移动。如果这样做，将违反Pin合约。</p>
>
> A mistake that is easy to make is forgetting to shadow the original variable
> since you could drop the `Pin` and move the data after `&'a mut T`
> like shown below (which violates the Pin contract):
>
> <p class="cn">容易犯的一个错误是忘记隐藏原始变量，因为您可以删除`Pin`并将数据移动到`&'a mut T`之后，如下图所示（这违反了Pin约定）：</p>
>
> ```rust
> fn main() {
>    let mut test1 = Test::new("test1");
>    let mut test1_pin = unsafe { Pin::new_unchecked(&mut test1) };
>    Test::init(test1_pin.as_mut());
>
>    drop(test1_pin);
>    println!(r#"test1.b points to "test1": {:?}..."#, test1.b);
>
>    let mut test2 = Test::new("test2");
>    mem::swap(&mut test1, &mut test2);
>    println!("... and now it points nowhere: {:?}", test1.b);
> }
> # use std::pin::Pin;
> # use std::marker::PhantomPinned;
> # use std::mem;
> #
> # #[derive(Debug)]
> # struct Test {
> #     a: String,
> #     b: *const String,
> #     _marker: PhantomPinned,
> # }
> #
> #
> # impl Test {
> #     fn new(txt: &str) -> Self {
> #         Test {
> #             a: String::from(txt),
> #             b: std::ptr::null(),
> #             // This makes our type `!Unpin`
> #             _marker: PhantomPinned,
> #         }
> #     }
> #
> #     fn init<'a>(self: Pin<&'a mut Self>) {
> #         let self_ptr: *const String = &self.a;
> #         let this = unsafe { self.get_unchecked_mut() };
> #         this.b = self_ptr;
> #     }
> #
> #     fn a<'a>(self: Pin<&'a Self>) -> &'a str {
> #         &self.get_ref().a
> #     }
> #
> #     fn b<'a>(self: Pin<&'a Self>) -> &'a String {
> #         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
> #         unsafe { &*(self.b) }
> #     }
> # }
> ```

### Pinning to the Heap(固定到堆)

Pinning an `!Unpin` type to the heap gives our data a stable address so we know
that the data we point to can't move after it's pinned. In contrast to stack
pinning, we know that the data will be pinned for the lifetime of the object.

<p class="cn">
固定一个`!Unpin`类型为堆提供了一个稳定的地址，因此我们知道所指向的数据在被固定后无法移动。
与栈固定不同，我们知道数据将在对象的生存期内固定。
</p>

```rust, edition2018
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &str) -> Pin<Box<Self>> {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        unsafe { &*(self.b) }
    }
}

pub fn main() {
    let test1 = Test::new("test1");
    let test2 = Test::new("test2");

    println!("a: {}, b: {}",test1.as_ref().a(), test1.as_ref().b());
    println!("a: {}, b: {}",test2.as_ref().a(), test2.as_ref().b());
}
```

Some functions require the futures they work with to be `Unpin`. To use a
`Future` or `Stream` that isn't `Unpin` with a function that requires
`Unpin` types, you'll first have to pin the value using either
`Box::pin` (to create a `Pin<Box<T>>`) or the `pin_utils::pin_mut!` macro
(to create a `Pin<&mut T>`). `Pin<Box<Fut>>` and `Pin<&mut Fut>` can both be
used as futures, and both implement `Unpin`.

<p class="cn">
有些函数要求它们使用的future是`Unpin`。要将非`Unpin`的`Future`或`Stream`与需要`Unpin`类型的函数一起使用，
首先必须使用`Box::pin`（创建``Pin<Box<T>>`）或`pin_utils::pin_mut!`宏（创建`Pin<&mut T>`）。
`Pin<Box<Fut>>` 和 `Pin<&mut Fut>`都可以用作future，并且都实现了`Unpin`。
</p>

For example:

```rust,edition2018,ignore
use pin_utils::pin_mut; // `pin_utils` is a handy crate available on crates.io

// A function which takes a `Future` that implements `Unpin`.
fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { /* ... */ }

let fut = async { /* ... */ };
execute_unpin_future(fut); // Error: `fut` does not implement `Unpin` trait

// Pinning with `Box`:
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
```

## Summary(总结)

1. If `T: Unpin` (which is the default), then `Pin<'a, T>` is entirely
equivalent to `&'a mut T`. in other words: `Unpin` means it's OK for this type
to be moved even when pinned, so `Pin` will have no effect on such a type.

1. <p class="cn">如果`T: Unpin`（默认设置），那么`Pin<'a, T>`完全等同于`&'a mut T`。换言之：`Unpin`表示即使在固定时也可以移动此类型，因此`Pin`对此类类型没有影响。</p>

2. Getting a `&mut T` to a pinned T requires unsafe if `T: !Unpin`.

2. <p class="cn">要使`&mut T`成为固定的T，如果`T: !Unpin`需要不安全代码。</p>

3. Most standard library types implement `Unpin`. The same goes for most
"normal" types you encounter in Rust. A `Future` generated by async/await is an exception to this rule.

3. <p class="cn">大多数标准库类型都实现`Unpin`。你在Rust中遇到的大多数`正常`类型也是如此。由async/await生成的`Future`是此规则的一个例外。</p>

4. You can add a `!Unpin` bound on a type on nightly with a feature flag, or
by adding `std::marker::PhantomPinned` to your type on stable.

4. <p class="cn">在nightly版本中使用特性flag，您可以在类型上添加`!Unpin`，或者在stable版本上的类型中添加`std::marker::PhantomPinned`。</p>

5. You can either pin data to the stack or to the heap.

5. <p class="cn">您可以将数据固定到栈或堆。</p>

6. Pinning a `!Unpin` object to the stack requires `unsafe`

6. <p class="cn">固定一个`!Unpin`对象到栈需要`unsafe`代码</p>

7. Pinning a `!Unpin` object to the heap does not require `unsafe`. There is a shortcut for doing this using `Box::pin`.

7. <p class="cn">固定一个`!Unpin`对象到堆不需要`unsafe`代码。有一个进行此操作的快捷方式，即使用`Box::pin`。</p>

8. For pinned data where `T: !Unpin` you have to maintain the invariant that its memory will not
get invalidated or repurposed _from the moment it gets pinned until when drop_ is called. This is
an important part of the _pin contract_.

8. <p class="cn">对于固定数据，其中`T: !Unpin`您必须保持不变量，使其内存<i>从被固定的那一刻起直到调用drop时</i>都不会失效或重新调整用途。这就是<i>pin合约</i>的一个重要部分。</p>

["Executing `Future`s and Tasks"]: ../02_execution/01_chapter.md
[the `Future` trait]: ../02_execution/02_future.md
[pin_utils]: https://docs.rs/pin-utils/
